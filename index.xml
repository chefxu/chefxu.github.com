<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>代码苦旅</title>
    <link>http://chefxu.github.io/</link>
    <description>Recent content on 代码苦旅</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 02 May 2016 15:38:50 +0800</lastBuildDate>
    <atom:link href="http://chefxu.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Stone alpha版发布</title>
      <link>http://chefxu.github.io/post/stone-alpha/</link>
      <pubDate>Mon, 02 May 2016 15:38:50 +0800</pubDate>
      
      <guid>http://chefxu.github.io/post/stone-alpha/</guid>
      <description>

&lt;h1 id=&#34;stone的由来:df9104273865eb60abece7dc4c3e68c4&#34;&gt;Stone的由来&lt;/h1&gt;

&lt;p&gt;Stone最初的目的是为了解决Laravel框架的性能问题， 公司是Laravel框架的重度使用者，在绝大多数场合， Laravel都可以很好的应对，但是对于一些并发量高的应用，比如定时抢购的活动， 存在一些问题。问题的根本原因是：Laravel框架本身性能不高， 由于PHP程序执行机制的特殊性，框架的性能会极大的限制程序的并发能力，这一点相信很多选择或者没选择Laravel的人都有体会。去年年底， 在解决一个性能问题的时候， 尝试性的使用Laravel+Swoole的组合搭建一个TCP的业务Server， 在Laravel资源完全初始化的情况下， 使用Swoole常驻内存并对外提供服务， 这样每个请求就不必再去初始化资源， 从而得到极高的性能提升。然后， 需要对前端提供接口， 所以TCP Server前面再放置一个lumen，对外提供HTTP接口服务。为了便于管理， 我给这个方案取了一个名字：Stone，希望它能稳定发展， 成为性能解决方案的一块基石。&lt;/p&gt;

&lt;p&gt;到目前为止，Stone作为接口的方式已经在线上稳定运行超过3个月，有一些很重要的接口也在使用。这里面， 需要重点赞一下&lt;a href=&#34;http://www.swoole.com/&#34;&gt;Swoole&lt;/a&gt;，因为是有了swoole的高性能和稳定， 才有后面的这些事情。&lt;/p&gt;

&lt;h1 id=&#34;早期stone的一些缺陷:df9104273865eb60abece7dc4c3e68c4&#34;&gt;早期Stone的一些缺陷&lt;/h1&gt;

&lt;p&gt;早期Stone的方案缺陷主要体现在两方面：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;程序架构变得复杂，加大测试难度，同时并发性能受限于lumen。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PHP以简单快速得到大家喜爱， lumen的方式， 程序被分离到laravel和lumen中，加大管理难度。&lt;/li&gt;
&lt;li&gt;Swoole常驻内存， 修改调试需要不断重启进程&lt;/li&gt;
&lt;li&gt;lumen虽然性能不算差， 但是和swoole比起来相差还是很远， 并发要求很高的场合， 还是会成为瓶颈&lt;/li&gt;
&lt;li&gt;当方案出现问题时， 无法快速降级&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;适用范围较窄&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只适用一些无状态的接口调用的方式&lt;/li&gt;
&lt;li&gt;不支持视图显示， 不支持Session&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;stone近期的工作:df9104273865eb60abece7dc4c3e68c4&#34;&gt;Stone近期的工作&lt;/h1&gt;

&lt;p&gt;可以参看之前写的一个&lt;a href=&#34;http://chefxu.github.io/post/stone_roadmap/&#34;&gt;优化计划&lt;/a&gt;， 目前基本达到的预期的效果。
主要工作为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;提高了Stone的适用性， 提供Stone-Web和Stone-Server两种运行方案。前者针对页面后者针对API服务。&lt;/li&gt;
&lt;li&gt;加强了Stone的兼容性，提供Laravel4.x和Laravel5.x的支持， 支持composer安装&lt;/li&gt;
&lt;li&gt;避免修改Laravel代码，代价是引入了对runkit的依赖， 但是我认为是值得的。 当然， 如果你不方便使用runkit，倾向于修改laravel源码， 也是可以的。&lt;/li&gt;
&lt;li&gt;简化了架构， 去除了lumen的依赖， 实现了FastCGI协议， 直接和nginx交互， 大大提高了性能。&lt;/li&gt;
&lt;li&gt;大大简化了使用难度和降级难度， 极小的修改后使用Stone进程替代PHP-FPM就能使用， 降级时替换回来即可。你甚至可以同时使用两种方式， 同一份代码， 只有性能要求高的接口才使用Stone。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;关于stone的一些测试数据:df9104273865eb60abece7dc4c3e68c4&#34;&gt;关于Stone的一些测试数据&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;线上核心接口请求次数累计超过20亿次，运行稳定&lt;/li&gt;
&lt;li&gt;Laravel5下测试，Stone-Web RPS大于3000， Stone-Server RPS大于8500，同等条件下，原始的Laravel RPS只有120.&lt;/li&gt;
&lt;li&gt;线上运行超过2年的Laravel4 项目， 包括2000多个路由， 大量的过滤器等， Stone-Web RPS大于1000， 同等条件下， Laravel RPS只有80多。&lt;/li&gt;
&lt;li&gt;一个实际项目的首页， 包含大量的数据库查询， Stone-Web RPS 为360多， 同等条件下， Laravel RPS只有30多。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;进一步了解stone:df9104273865eb60abece7dc4c3e68c4&#34;&gt;进一步了解Stone&lt;/h1&gt;

&lt;p&gt;只需5分钟， 为你的Laravel项目提供10倍以上的性能提升， 不想试试吗？
如果你对此感兴趣， 可以继续了解Stone是怎么优化Laravel性能的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于Stone的一些计划</title>
      <link>http://chefxu.github.io/post/stone_roadmap/</link>
      <pubDate>Sat, 23 Apr 2016 00:25:08 +0800</pubDate>
      
      <guid>http://chefxu.github.io/post/stone_roadmap/</guid>
      <description>

&lt;h1 id=&#34;关于:ba2bc2ee0383c786486da34d2d96d326&#34;&gt;关于&lt;/h1&gt;

&lt;p&gt;Stone是我在&lt;a href=&#34;http://www.qufenqi.com&#34;&gt;趣分期&lt;/a&gt;工作中发起的一个性能优化的项目，旨在解决基于laravel编写的接口的性能问题。根据之前的使用经验，在一台8核的PC上，一个laravel的&amp;rdquo;hello，world&amp;rdquo;程序， RPS也只有100多。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;已经开启opcode cache， 关闭debug， 运行 php ./artisan optimize 优化过&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;15年年底的时候要求给出一个流量提升10倍的技术应对方案， 于是就有了Stone这个项目。 Stone最开始是定位于一个TCP业务Server。使用lumen对外提供HTTP接口。目前已经支撑了核心业务白条接口的请求以及一些读写cookie的请求。目前请求次数已经超过13亿次， 两台服务器，负载都很低。&lt;/p&gt;

&lt;h1 id=&#34;目前的一些进展:ba2bc2ee0383c786486da34d2d96d326&#34;&gt;目前的一些进展&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;实现了FastCGI协议， 直接与nginx通信， 摆脱了lumen的依赖， 性能高达7500RPS&lt;/li&gt;
&lt;li&gt;实现了基于Unix domain socket的进程通信， 进一步提高性能10%&lt;/li&gt;
&lt;li&gt;实现了基本的RAML接口设计规范&lt;/li&gt;
&lt;li&gt;适配Laravel5.1框架进展顺利&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;计划:ba2bc2ee0383c786486da34d2d96d326&#34;&gt;计划&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;将拆分为两部分， Stone-Web和Stone-API，名字暂定。&lt;/li&gt;
&lt;li&gt;Stone-Web目标100%兼容laravel5.1，提升laravel框架性能10倍以上，让大象可以优雅地跳舞&lt;/li&gt;
&lt;li&gt;Stone-API专注于高性能API，围绕RAML规范，打造一整套API设计工具集&lt;/li&gt;
&lt;li&gt;持续反馈Swoole社区&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>分析，理解，优化Laravel</title>
      <link>http://chefxu.github.io/post/deepin_laravel/</link>
      <pubDate>Tue, 19 Apr 2016 19:44:07 +0800</pubDate>
      
      <guid>http://chefxu.github.io/post/deepin_laravel/</guid>
      <description>

&lt;h1 id=&#34;前言:9342adb7b594d3cbcff5efa79997fd88&#34;&gt;前言&lt;/h1&gt;

&lt;p&gt;使用Laravel接近两年了， 从4.2到现在的5.2。大多数情况下，Laravel都能很好的支撑我们的系统。不管你是否使用或打算使用， 了解Laravel的设计对于提高程序水平也很有帮助。本文是我的一个学习laravel的过程， 也是我实现高性能server &lt;a href=&#34;https://github.com/chefxu/stone&#34;&gt;stone&lt;/a&gt;下一个目标的过程。限于本人水平有限，错误在所难免，希望大家不吝指正。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：因为是边写边改， 所以内容目录随时会有调整。&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;一个http请求的执行流程:9342adb7b594d3cbcff5efa79997fd88&#34;&gt;一个HTTP请求的执行流程&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建app， app本质上是一个ioc容器（Illuminate\Container\Container），这个概念对于laravel很重要，laravel的核心组件都会注册到这个容器里面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$app = new Illuminate\Foundation\Application(
    realpath(__DIR__.&#39;/../&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;初始化全局ioc容器app， 并把自己本身注册进去&lt;/li&gt;
&lt;li&gt;注册基本的Service Provider: EventServiceProvider, RoutingServiceProvider&lt;/li&gt;
&lt;li&gt;注册核心的class别名，参看：registerCoreContainerAliases&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;核心接口绑定， 如果需替换自己实现的Kernel， 可以修改这里。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// http处理
$app-&amp;gt;singleton(
    Illuminate\Contracts\Http\Kernel::class,
    App\Http\Kernel::class
);


// console处理
$app-&amp;gt;singleton(
    Illuminate\Contracts\Console\Kernel::class,
    App\Console\Kernel::class
);


// 异常处理
$app-&amp;gt;singleton(
    Illuminate\Contracts\Debug\ExceptionHandler::class,
    App\Exceptions\Handler::class
);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建Kernel，注意这里是基于接口来创建， 最终创建什么实例， 依赖于前面的接口绑定。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$kernel = $app-&amp;gt;make(Illuminate\Contracts\Http\Kernel::class);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;这个代码最终实例化的是App\Http\Kernel，App\Http\Kernel继承自Illuminate\Foundation\Http\Kernel。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接口绑定是laravel框架设计精华所在，laravel框架的核心组件全部都实现了接口，在laravel里统一放在Contracts下。这给予了开发者极大的自由，可以在程序中通过修改接口绑定来改变组件的实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;chunfang@office:~/base.account$ ls vendor/laravel/framework/src/Illuminate/Contracts/
Auth          Bus    composer.json  Console    Cookie    Debug       Events
Foundation  Http     Mail        Pipeline  Redis    Support     View
Broadcasting  Cache  Config         Container  Database  Encryption  Filesystem
Hashing     Logging  Pagination  Queue     Routing  Validation
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;基于全局变量创建request对象， 交由Kernel处理， 这是请求处理的核心所在。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基于全局变量创建请求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$request = Illuminate\Http\Request::capture()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Kerner处理request&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$response = $kernel-&amp;gt;handle($request);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请求方法关键细节：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;public function handle($request)
{
    try {
        // 允许使用_method来模拟PUT，DELETE等
        $request-&amp;gt;enableHttpMethodParameterOverride();


        // 处理请求返回响应
        $response = $this-&amp;gt;sendRequestThroughRouter($request);
    } catch (Exception $e) {
        $this-&amp;gt;reportException($e);


        $response = $this-&amp;gt;renderException($request, $e);
    } catch (Throwable $e) {
        $this-&amp;gt;reportException($e = new FatalThrowableError($e));


        $response = $this-&amp;gt;renderException($request, $e);
    }


    // 发射事件
    $this-&amp;gt;app[&#39;events&#39;]-&amp;gt;fire(&#39;kernel.handled&#39;, [$request, $response]);


    return $response;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;处理请求返回响应关键细节：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;protected function sendRequestThroughRouter($request)
{
    $this-&amp;gt;app-&amp;gt;instance(&#39;request&#39;, $request);


    Facade::clearResolvedInstance(&#39;request&#39;);


    // 初始化请求资源
    $this-&amp;gt;bootstrap();


    // 流水线处理
    return (new Pipeline($this-&amp;gt;app))
                -&amp;gt;send($request)
                -&amp;gt;through($this-&amp;gt;app-&amp;gt;shouldSkipMiddleware() ? [] : $this-&amp;gt;middleware)
                -&amp;gt;then($this-&amp;gt;dispatchToRouter());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化资源关键细节：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;protected $bootstrappers = [
    &#39;Illuminate\Foundation\Bootstrap\DetectEnvironment&#39;,
    &#39;Illuminate\Foundation\Bootstrap\LoadConfiguration&#39;,
    &#39;Illuminate\Foundation\Bootstrap\ConfigureLogging&#39;,
    &#39;Illuminate\Foundation\Bootstrap\HandleExceptions&#39;,
    &#39;Illuminate\Foundation\Bootstrap\RegisterFacades&#39;,
    &#39;Illuminate\Foundation\Bootstrap\RegisterProviders&#39;,
    &#39;Illuminate\Foundation\Bootstrap\BootProviders&#39;,
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;流水线实现细节：
&lt;a href=&#34;http://www.jianshu.com/p/3c2791a525d0&#34;&gt;理解Laravel中的pipeline&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;路由处理关键细节：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;public function dispatch(Request $request)
{
    $this-&amp;gt;currentRequest = $request;


    $response = $this-&amp;gt;dispatchToRoute($request);


    return $this-&amp;gt;prepareResponse($request, $response);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;public function dispatchToRoute(Request $request)
{
    // First we will find a route that matches this request. We will also set the
    // route resolver on the request so middlewares assigned to the route will
    // receive access to this route instance for checking of the parameters.
    $route = $this-&amp;gt;findRoute($request);


    $request-&amp;gt;setRouteResolver(function () use ($route) {
        return $route;
    });


    $this-&amp;gt;events-&amp;gt;fire(new Events\RouteMatched($route, $request));


    $response = $this-&amp;gt;runRouteWithinStack($route, $request);


    return $this-&amp;gt;prepareResponse($request, $response);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;路由执行实际动作关键细节：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;public function run(Request $request)
{
    $this-&amp;gt;container = $this-&amp;gt;container ?: new Container;


    try {
        if (! is_string($this-&amp;gt;action[&#39;uses&#39;])) {
            return $this-&amp;gt;runCallable($request);
        }


        return $this-&amp;gt;runController($request);
    } catch (HttpResponseException $e) {
        return $e-&amp;gt;getResponse();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;输出到客户端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$response-&amp;gt;send();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;依次调用结束动作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$kernel-&amp;gt;terminate($request, $response);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ioc容器的实现:9342adb7b594d3cbcff5efa79997fd88&#34;&gt;IOC容器的实现&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://code.tutsplus.com/tutorials/digging-in-to-laravels-ioc-container--cms-22167&#34;&gt;Digging in to Laravel&amp;rsquo;s IoC Container&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;实现自己的路由替代laravel路由:9342adb7b594d3cbcff5efa79997fd88&#34;&gt;实现自己的路由替代Laravel路由&lt;/h1&gt;

&lt;p&gt;编写中&lt;/p&gt;

&lt;h1 id=&#34;浅析资源初始化:9342adb7b594d3cbcff5efa79997fd88&#34;&gt;浅析资源初始化&lt;/h1&gt;

&lt;p&gt;编写中&lt;/p&gt;

&lt;h1 id=&#34;laravel-pipeline的实现:9342adb7b594d3cbcff5efa79997fd88&#34;&gt;Laravel Pipeline的实现&lt;/h1&gt;

&lt;p&gt;编写中&lt;/p&gt;

&lt;h1 id=&#34;基于stone实现高性能kernel:9342adb7b594d3cbcff5efa79997fd88&#34;&gt;基于Stone实现高性能Kernel&lt;/h1&gt;

&lt;p&gt;编写中&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>test post</title>
      <link>http://chefxu.github.io/post/test/</link>
      <pubDate>Tue, 19 Apr 2016 19:04:07 +0800</pubDate>
      
      <guid>http://chefxu.github.io/post/test/</guid>
      <description>

&lt;h1 id=&#34;hello-world:b128b7694e4de962e0088bcb1bcb254f&#34;&gt;hello world&lt;/h1&gt;
</description>
    </item>
    
  </channel>
</rss>